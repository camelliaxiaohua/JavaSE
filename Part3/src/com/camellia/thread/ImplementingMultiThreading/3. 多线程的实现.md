# 多线程的实现

在Java中实现多线程主要有**两种方式**：继承`Thread`类和实现`Runnable`接口。

## 一、继承Thread类

继承`Thread`类是实现多线程的一种方式，通过创建一个新的类继承自`Thread`类，并重写其`run()`方法来定义线程的任务。

### 1.1 实现步骤
1. 创建一个继承自`Thread`的类。
2. 重写`run()`方法，定义线程执行的代码。
3. 创建`Thread`类的实例。
4. 调用实例的`start()`方法来启动线程。

### 1.2 示例代码
```java
package com.camellia.thread.ImplementingMultiThreading;

/**
 * 本类展示了在Java中实现多线程的第二种方式：
 * 通过实现`java.lang.Runnable`接口来创建和运行线程。
 * 在这个示例中，我们定义了一个实现了`Runnable`接口的类`MyRunnable`，并在主线程中创建并启动了一个线程。
 */
public class ThreadByRunnable {

    /**
     * 程序的入口点。创建并启动一个线程，同时在主线程中执行另一段代码。
     * 通过这种方式，我们可以同时执行多个任务，实现多线程编程。
     *
     * @param args 命令行参数
     */
    public static void main(String[] args) {
        // 创建一个实现了Runnable接口的对象
        Runnable runnable = new MyRunnable();

        // 创建一个Thread对象，并将Runnable对象传递给它
        Thread thread = new Thread(runnable);

        // 启动线程
        thread.start();

        // 这段代码在主线程中执行
        // 主线程执行一个循环，输出100次
        for (int i = 0; i < 100; i++) {
            System.out.println("Main is running.\t" + i);
        }
    }
}

/**
 * 严格来说，这个不是一个线程类
 * 它是一个普通的类，只不过实现了一个Runnable接口。
 * 实现Runnable接口意味着这个类可以作为线程执行的任务。
 */
class MyRunnable implements Runnable {

    /**
     * 实现Runnable接口中的run方法。
     * 当线程启动时，会调用run方法中的代码。
     */
    @Override
    public void run() {
        // 子线程执行一个循环，输出100次
        for (int i = 0; i < 100; i++) {
            System.out.println("My thread is running.\t" + i);
        }
    }
}

```

### 1.3 注意事项

1. **run()方法**：
   - 直接调用`run()`方法不**会启动新的线程**。
   - 在Java中，方法体内的代码必须遵循自上而下的顺序逐行执行。
   - 如果`run()`方法没有结束，`main`方法将无法继续执行。

![](https://github.com/camelliaxiaohua/JavaSE/blob/master/Part3/src/assert/%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E8%B0%83%E7%94%A8run%E6%96%B9%E6%B3%95.png)

2. **start()方法**：
   - 调用`start()`方法会启动一个新的线程。
   - 在Java中，方法体内的代码必须遵循自上而下的顺序逐行执行。
   - `start()`方法一旦调用，它会迅速结束，因为其主要作用是启动一个新的线程。一旦新线程启动成功，`start()`方法就结束了。

![](https://github.com/camelliaxiaohua/JavaSE/blob/master/Part3/src/assert/%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8start%E6%96%B9%E6%B3%95.png)

## 二、实现Runnable接口

实现`Runnable`接口是另一种实现多线程的方法，这种方式更加灵活，因为它使得类可以继承其他类。
通过实现`Runnable`接口，定义线程的任务，然后将该任务传递给`Thread`对象。

### 2.1 实现步骤
1. 创建一个实现`Runnable`接口的类。
2. 实现`run()`方法，定义线程的任务。
3. 创建`Thread`类的实例，传入实现了`Runnable`接口的对象。
4. 调用`Thread`实例的`start()`方法来启动线程。

### 2.2 示例代码

#### 2.2.1 显式的创建
```java
package com.camellia.thread.ImplementingMultiThreading;
/**
 * 本类展示了在Java中实现多线程的第二种方式：
 * 通过实现`java.lang.Runnable`接口来创建和运行线程。
 * 在这个示例中，我们定义了一个实现了`Runnable`接口的类`MyRunnable`，并在主线程中创建并启动了一个线程。
 */
public class ThreadByRunnable {

    /**
     * 程序的入口点。创建并启动一个线程，同时在主线程中执行另一段代码。
     * 通过这种方式，我们可以同时执行多个任务，实现多线程编程。
     *
     * @param args 命令行参数
     */
    public static void main(String[] args) {
        // 创建一个实现了Runnable接口的对象
        Runnable runnable = new MyRunnable();

        // 创建一个Thread对象，并将Runnable对象传递给它
        Thread thread = new Thread(runnable);

        // 启动线程
        thread.start();

        // 这段代码在主线程中执行
        // 主线程执行一个循环，输出100次
        for (int i = 0; i < 100; i++) {
            System.out.println("Main is running.\t" + i);
        }
    }
}

/**
 * 严格来说，这个不是一个线程类
 * 它是一个普通的类，只不过实现了一个Runnable接口。
 * 实现Runnable接口意味着这个类可以作为线程执行的任务。
 */
class MyRunnable implements Runnable {

    /**
     * 实现Runnable接口中的run方法。
     * 当线程启动时，会调用run方法中的代码。
     */
    @Override
    public void run() {
        // 子线程执行一个循环，输出100次
        for (int i = 0; i < 100; i++) {
            System.out.println("My thread is running.\t" + i);
        }
    }
}
```

#### 2.2.2 使用匿名类创建

```java
package com.camellia.thread.ImplementingMultiThreading;

import org.junit.jupiter.api.Test;

/**
 * 本类展示了如何使用匿名内部类来实现多线程编程。
 * 在Java中，匿名内部类是一种快速实现接口或继承类的一种方式，不需要显式地定义类。
 */
public class AnonymousThreadByRunnable {

    /**
     * 测试方法，演示如何通过匿名内部类实现`Runnable`接口并创建一个线程。
     * 这个方法中创建了一个新的线程，该线程执行一个循环，输出1000次。
     *
     * 主线程和新线程同时运行，演示了并行执行。
     */
    @Test
    public void testAnonymousThreadByRunnable01() {
        Thread thread = new Thread(new MyRunnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    System.out.println("my thread is running\t" + i);
                }
            }
        });
        thread.start();

        // 主线程执行一个循环，输出1000次
        for (int i = 0; i < 1000; i++) {
            System.out.println("Main is running\t" + i);
        }
    }

    /**
     * 测试方法，另一种方式演示如何通过匿名内部类实现`Runnable`接口并启动一个新线程。
     * 这里直接在新线程中创建并启动了一个匿名Runnable对象。
     */
    @Test
    public void testAnonymousThreadByRunnable02() {
        // 创建并启动一个新线程，执行一个循环，输出1000次
        new Thread(new MyRunnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    System.out.println("my thread is running\t" + i);
                }
            }
        }).start();

        // 主线程执行一个循环，输出1000次
        for (int i = 0; i < 1000; i++) {
            System.out.println("Main is running\t" + i);
        }
    }
}

```

#### 2.2.3 选择使用继承`Thread`还是实现`Runnable`**
   1. **继承`Thread`**:
      - 直接，容易实现。
      - 不适合与Java的其他类（如GUI类）继承。
   2. **实现`Runnable`**:
      - 更加灵活，可以与其他类继承。
      - 是推荐的多线程编程方式，特别是在需要创建多个线程时。



