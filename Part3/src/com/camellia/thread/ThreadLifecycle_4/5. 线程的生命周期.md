# 线程的生命周期

Java 线程的生命周期描述了一个线程从创建到终止的整个过程。

## 一、线程的生命周期七个状态

1. **新建（New）**：
    - 当新创建一个线程对象时，线程处于新建状态。
    - 此时线程还没有开始运行，尚未分配 CPU 和其他资源。

2. **就绪（Runnable）**：
    - 当调用线程的 `start()` 方法后，线程进入就绪状态。
    - 处于就绪状态的线程已经分配了所有必要的资源，等待系统调度执行。

3. **运行（Running）**：
    - 当线程获取了 CPU 资源并开始执行时，线程进入运行状态。
    - 此时线程正在执行任务中，直到任务执行完毕或者发生阻塞。

4. **阻塞（Blocked）**：
    - 在特定情况下，线程会进入阻塞状态，暂时停止执行。
    - 常见的阻塞情况包括等待某个资源、等待输入/输出完成、等待获取锁等。

5. **等待（Waiting）**：
    - 线程处于等待状态，等待其他线程的通知或者特定条件的满足。
    - 进入等待状态的线程可以通过 `wait()`、`join()` 或者 `sleep()` 等方法触发。

6. **超时等待（Timed Waiting）**：
    - 线程等待一段指定的时间后自动恢复到就绪状态。
    - 通过 `sleep()`、`join(timeout)`、`wait(timeout)` 等方法可以使线程进入超时等待状态。

7. **终止（Terminated）**：
    - 线程执行完任务后或者因异常退出执行，进入终止状态。
    - 终止状态的线程不再运行，生命周期结束，无法再启动或者执行其他操作。

![](https://github.com/camelliaxiaohua/JavaSE/blob/master/Part3/src/assert/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE.png)

## 二、关于线程的休眠

### 2.1 sleep方法（休眠线程）

1. **静态方法 `sleep(long millis)`**
   - 方法签名：`static void sleep(long millis)`
   - **说明**：
      - 这是一个静态方法。
      - 没有返回值。
      - 参数是一个毫秒数。1秒 = 1000毫秒。

2. **方法作用**
   - 让当前线程进入休眠状态，也就是让当前线程放弃占有的CPU时间片，使其进入阻塞状态。
   - **具体含义**：当前线程不再占用CPU，让给其他线程使用。
   - **阻塞时长**：根据传入的毫秒参数决定。在指定的时间范围内，当前线程没有权利抢夺CPU时间片。

3. **“当前线程”解释**
   - `Thread.sleep(1000);` 这行代码在哪个线程中执行，那么当前线程就是那个线程。

4. **关于 `run` 方法**
   - 在重写 `run` 方法时，不能在方法声明位置使用 `throws` 抛出异常。

5. **使用 `sleep` 方法的场景**
   - `sleep` 方法可以用来模拟每隔固定时间调用一次程序。


```java
package com.camellia.thread.ThreadLifecycle_4;

public class ThreadSleepTest {

   /**
    * 程序的入口点。
    * 主线程将在开始时休眠5秒，然后打印出一系列消息。
    * 接着启动一个新的线程，该线程每隔一秒打印一次消息。
    *
    * @param args 命令行参数
    */
   public static void main(String[] args) {
      try {
         // 让当前线程休眠5秒（代码出现在主线程中，所以主线程休眠5秒）
         Thread.sleep(1000 * 5);
      } catch (InterruptedException e) {
         throw new RuntimeException(e);
      }

      // 主线程输出
      for (int i = 0; i < 10; i++) {
         System.out.println(Thread.currentThread().getName() + "===>" + i);
      }

      // 创建并启动新的线程
      Runnable myThread = new com.camellia.thread.ThreadLifecycle_4.sleep.MyThread();
      Thread thread = new Thread(myThread);
      thread.start();
   }
}

/**
 * 自定义的Runnable实现类。
 * 在run方法中，每隔一秒打印一次消息。
 */
class MyThread implements Runnable {

   /**
    * 实现Runnable接口中的run方法。
    * 当线程启动时，会执行此方法。
    */
   @Override
   public void run() {
      // 子线程输出，每隔一秒打印一次消息
      for (int i = 0; i < 10; i++) {
         System.out.println(Thread.currentThread().getName() + "===>" + i);
         try {
            // 让当前线程休眠1秒
            Thread.sleep(1000 * 1);
         } catch (InterruptedException e) {
            e.printStackTrace();
         }
      }
   }
}
```

### 2.2 sleep方法注意事项（面试）

```java
package com.camellia.thread.ThreadLifecycle_4.sleep;

/**
 * 演示 Thread.sleep() 方法的使用和效果。
 * 说明：Thread.sleep() 是一个静态方法，它让当前线程休眠指定的时间。
 * 虽然可以通过线程实例调用，但实际上是让当前线程休眠，而不是调用线程实例。
 */
public class ThreadSleep02 {
    
    public static void main(String[] args) throws InterruptedException {
        // 创建线程实例
        Thread t = new MyThread02();
        t.setName("MyThread");

        // 调用sleep方法，让当前线程（即主线程）休眠6秒
        // 虽然是通过线程实例调用，但实际上是让主线程休眠
        Thread.sleep(1000 * 6);

        // 启动线程
        t.start();

        // 判断这个休眠效果作用在哪个线程
        // sleep是静态方法，虽然是用实例调用，但是实际上作用于当前线程
    }
}

/**
 * 自定义的线程类，继承自Thread。
 * 在run方法中打印当前线程的名称和一个计数值。
 */
class MyThread02 extends Thread {

    /**
     * 重写run方法，在线程启动后执行。
     */
    @Override
    public void run() {
        // 循环打印当前线程的名称和计数值
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
    }
}
```

### 2.3 interrupt方法（唤醒线程）

- **interrupt 是实例方法**：
   - 哪个实例对象调用 `interrupt` 方法，就终止哪个线程的睡眠。

- **底层实现原理**：
   - 利用了异常处理机制。

- **工作原理**：
   - 当调用 `interrupt` 方法时，如果线程正在睡眠，会抛出 `InterruptedException` 异常。
   - 然后捕获异常终止睡眠。

- **注意事项**：
   - 如果在 `catch` 子句中继续抛出异常则不会中断，因为抛出异常等于没处理。
   - 可以在 `catch` 子句中打印异常信息，也可以执行自定义语句。

```java
package com.camellia.thread.ThreadLifecycle_4.sleep;

/**
 * 如何解除线程的睡眠（怎么解除线程因sleep导致的阻塞，让其开始抢夺CPU时间片。）
 */
public class ThreadSleep03 {
    
    public static void main(String[] args) {
        // 创建并启动线程
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + " begin");
                try {
                    // 线程休眠一年
                    Thread.sleep(1000 * 60 * 60 * 24 * 365);
                } catch (InterruptedException e) {
                    // 捕获InterruptedException异常，并终止休眠
                    System.out.println(Thread.currentThread().getName() + " was interrupted.");
                }
                // 睡眠一年后或者被中断后，继续执行
                System.out.println("Thread " + Thread.currentThread().getName() + " is running.");
            }
        });
        thread.start();

        // 主线程
        // 需求：5秒后，唤醒正在睡眠的Thread-0线程
        try {
            Thread.sleep(1000 * 5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread.interrupt();
    }
}

```


## 三、线程的终止方法

在Java中，终止线程并不是一个简单的操作，因为不建议直接强制终止一个线程。
Java不再支持如 `Thread.stop()` 方法，因为这种方式可能会导致数据的不一致和资源的泄漏。相反，推荐的方式是通过设置一个标志来通知线程自行终止。


### 3.1 使用标志位
通过设置一个标志位，让线程在下次检查到该标志位时自行终止。这种方式是最推荐的，因为它允许线程在终止前完成必要的清理工作。

```java
public class MyThread extends Thread {
    private volatile boolean running = true;

    public void run() {
        while (running) {
            // 线程执行的代码
            System.out.println("Thread is running...");
            
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt(); // 重新设置中断状态
                System.out.println("Thread was interrupted, Failed to complete operation");
            }
        }
        System.out.println("Thread is stopping...");
    }

    public void stopThread() {
        running = false;
    }
}
```

在主程序中，可以通过调用 `stopThread()` 方法来终止线程：

```java
public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
        
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        myThread.stopThread();
    }
}
```

## 四、守护线程

守护线程（Daemon Thread）是 Java 中的一种特殊线程，其主要用于后台服务，如垃圾回收器等。
与用户线程不同，当所有用户线程都结束时，守护线程会自动终止。
守护线程的存在并不会阻止 JVM 退出。守护线程的生命周期依赖于用户线程，只有在所有用户线程都结束时，JVM 才会终止守护线程。

### 4.1 创建守护线程

1. **创建线程对象**：可以通过继承 `Thread` 类或实现 `Runnable` 接口来创建线程对象。
2. **将线程设置为守护线程**：使用 `Thread` 类的 `setDaemon(true)` 方法将线程设置为守护线程。**必须在启动线程之前调用此方法**，否则会抛出 `IllegalThreadStateException` 异常。
3. **启动线程**：调用 `start()` 方法启动线程。

### 4.2 示例代码

```java
package com.camellia.thread.ThreadLifecycle_4.daemon_thread;

/**
 * <p>
 * 1. 在JVM中，始终存在一个隐藏的守护线程，即垃圾回收器（GC）线程。
 * <p>
 * 2. 如何将线程设置为守护线程：
 *    - 在启动线程之前使用 setDaemon(true) 方法将其设置为守护线程。
 */
public class DaemonThreadTest {
    public static void main(String[] args) {
        // 创建 MyThread 的实例
        MyThread myThread = new MyThread();
        // 在启动线程之前将其设置为守护线程
        myThread.setDaemon(true);
        myThread.start();

        // 主线程（用户线程）
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() + "===>" + i);
            try {
                Thread.sleep(1000); // 线程休眠1秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // 虽然 MyThread 执行了一个无限循环，但设置为守护线程意味着当所有用户线程（如主线程）结束时它会终止。
    }
}

/**
 * MyThread 类继承自 Thread，演示了简单的守护线程行为。
 */
class MyThread extends Thread {

    /**
     * 线程启动后执行的 run 方法。
     */
    @Override
    public void run() {
        int i = 0;
        while (true) {
            System.out.println(Thread.currentThread().getName() + "\t" + (++i));
        }
    }
}
```

## 五、定时任务

### 5.1 `Timer` 和 `TimerTask` 的基本概念

- **`Timer`**：用于安排和管理定时任务的类。它可以调度任务在将来的某个时间点执行，或者周期性地执行。
- **`TimerTask`**：一个抽象类，表示一个可以被 `Timer` 调度的任务。需要继承这个类并实现 `run()` 方法来定义任务的具体内容。

### 5.2 实现步骤

1. **创建一个 `Timer` 实例**。
2. **创建一个继承自 `TimerTask` 的任务类，并实现其 `run()` 方法**。
3. **使用 `Timer` 实例安排任务的执行时间和周期**。

### 5.3 示例代码


```java
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class ScheduledTasksTest {
    public static void main(String[] args) throws ParseException {
        // 创建定时器对象
        // 如果这个定时器执行的任务是一个后台任务，是一个守护任务，建议将其定义为守护线程。
        Timer timer = new Timer(true);
        
        // 指定定时任务的开始时间和间隔
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date firstDate = sdf.parse("2024-06-23 09:05:00");
        
        // 安排定时任务，每隔 1000 毫秒（1 秒）执行一次
        timer.schedule(new LogTimeTask(), firstDate, 1000);
        
        // 主线程继续运行，可以通过睡眠来观察定时任务的执行
        try {
            Thread.sleep(10000); // 主线程睡眠10秒，观察定时任务的执行
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

/**
 * 定时任务类：专门记录日期的定时任务类。
 */
public class LogTimeTask extends TimerTask {
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");
    int count = 0;
    @Override
    public void run() {
        // 执行任务
        Date now = new Date();
        String strTime = sdf.format(now);
        System.out.println(strTime+":"+(count++));
    }
}

```


### 5.4 其他定时任务方法

除了 `schedule(TimerTask task, Date time, long period)`，`Timer` 还有其他一些常用的调度方法：

- `schedule(TimerTask task, Date time)`：在指定的时间执行一次任务。
- `schedule(TimerTask task, long delay)`：在指定的延迟后执行一次任务。
- `scheduleAtFixedRate(TimerTask task, Date firstTime, long period)`：在指定的时间开始，按照固定的时间间隔执行任务。
- `scheduleAtFixedRate(TimerTask task, long delay, long period)`：在指定的延迟后开始，按照固定的时间间隔执行任务。
